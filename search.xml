<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[mac 合并分区的时候失败，你可以尝试下这个]]></title>
      <url>http://www.smallstrong.wang/2016/10/31/mac-%E5%90%88%E5%B9%B6%E5%88%86%E5%8C%BA%E7%9A%84%E6%97%B6%E5%80%99%E5%A4%B1%E8%B4%A5%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E4%B8%8B%E8%BF%99%E4%B8%AA/</url>
      <content type="html"><![CDATA[<p><center>mac分区小记</center><br><a id="more"></a></p>
<h1 id="mac分区合并"><a href="#mac分区合并" class="headerlink" title="mac分区合并"></a>mac分区合并</h1><blockquote>
<p>如果哪天你心血来潮，用bootcamp装了双系统，然后今后的某天又不想要了，然后你打开了分区助手，一顿瞎搞，最终发现那块分区回不去了，呀，还我空间，人家片么地方放了。。。</p>
</blockquote>
<ol>
<li>打开你的终端输入diskutil list,看到了你硬盘里面所有的分区，分别以disk0s(1,2,3,4)命名。</li>
<li>找到那块自己不想要想合并的区域了吧，来输入这条指令sudo diskutil eraseVolume JHFS+ deleteme /dev/disk0s3（disk0s3只是例子，看准了删，删错别找我。这里会让你输入密码）</li>
<li>打开分区工具，来还我空间，over.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[排序]]></title>
      <url>http://www.smallstrong.wang/2016/10/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E9%94%A6/</url>
      <content type="html"><![CDATA[<p><center>8大经典排序</center><br><a id="more"></a></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote>
<p>一共n个数排序就需要大循环n-1次，每大循环一次就是为了让这一次最大的数滚到序列最后。例如第二次大循环的时候，是为了让第一个数 到 倒数第二个数之间的这么多数里面的 最大数 滚到倒数第二个坑位里面，下面依次类推。</p>
</blockquote>
<pre><code>public class bubbleSort {  
public  bubbleSort(){  
int a[] = {4,12,64,5,4,62,99,98,54,56,17,18,23,34,15,3}; 
int temp=0;  
for(int i=0;i&lt;a.length-1;i++){  
    for(int j=0;j&lt;a.length-1-i;j++){  
        if(a[j]&gt;a[j+1]){  
        temp=a[j];  
        a[j]=a[j+1];  
        a[j+1]=temp;  
        }  
    }  
}  
for(int i=0;i&lt;a.length;i++)  
    System.out.println(a[i]);     
}  
}
</code></pre><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote>
<p>选最右边的数最为基数，大于等于这个基数的所有数排在这个基数右边，小于这个基数的数排在这个基数左边，那么好，这个基数的这个坑位就是他的了，没有人能和他抢这个坑位了。接着以刚刚那个基数左边的序列作为源序列，再这么来一次，刚刚左边序列的末尾的那个数字就会找到属于自己的坑位，当然右边序列也一样。这个一直递归找坑位下去，直到左右序列都只有一个数的时候坑位就找完了，排序就这样愉快的解决了。</p>
</blockquote>
<pre><code>public static void quickSort(int[] arer){
qsort(arr, 0, arr.length-1);
}
private static void qsort(int[] arr, int low, int high){
if (low &lt; high){
    int pivot=partition(arr, low, high);        //将数组分为两部分
    qsort(arr, low, pivot-1);                   //递归排序左子数组
    qsort(arr, pivot+1, high);                  //递归排序右子数组
}
}
private static int partition(int[] arr, int low, int high){
int pivot = arr[low];     //枢轴记录
while (low&lt;high){
    while (low&lt;high &amp;&amp; arr[high]&gt;=pivot) --high;
    arr[low]=arr[high];             //交换比枢轴小的记录到左端
    while (low&lt;high &amp;&amp; arr[low]&lt;=pivot) ++low;
    arr[high] = arr[low];           //交换比枢轴小的记录到右端
}
//扫描完成，枢轴到位
arr[low] = pivot;
//返回的是枢轴的位置
return low;
}
</code></pre><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><blockquote>
<p>一个数一个数插进去。一次大循环这个数组里面就多一个数。</p>
</blockquote>
<pre><code>public static void insertion_sort( int[] arr ) {
for( int i=0; i&lt;arr.length-1; i++ ) {    
    for( int j=i+1; j&gt;0; j-- ) {
        if( arr[j-1] &lt;= arr[j] )
            break;
        int temp = arr[j];
        arr[j] = arr[j-1];
        arr[j-1] = temp;
    }
}
}
</code></pre><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><blockquote>
<p>将一组数列等分成较多列，然后取出每一列的对应元素将其进行插入排序。接着将这个数列等分成比上次更少的列数，对每一列再进行插入排序。重复上述步骤，最后就是变成一列进行插入排序，over。</p>
</blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科是这么说的</a></p>
<pre><code>public static void shell_sort(int[] arr) {
    int gap = 1, i, j, len = arr.length;
    int temp;
    while (gap &lt; len / 3)
        gap = gap * 3 + 1; // &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...
    for (; gap &gt; 0; gap /= 3)
        for (i = gap; i &lt; len; i++) {
            temp = arr[i];
            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)
                arr[j + gap] = arr[j];
            arr[j + gap] = temp;
        }
}
</code></pre><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote>
<p> 重头排到尾，先在整个数组中找出最小的排在序列的首位，再重剩下的数组中找最小的，找到了放在排好序的序列后面跟着，一直找到排序完成。</p>
</blockquote>
<pre><code>public static void selection_sort(int[] arr) {
    int i, j, min, temp, len = arr.length;
    for (i = 0; i &lt; len - 1; i++) {
        min = i;
        for (j = i + 1; j &lt; len; j++)
            if (arr[min] &gt; arr[j])
                min = j;
        temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
    }
}    
</code></pre><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><blockquote>
<p>先有堆再排序。堆化数组，将堆的末端子节点作调整，使得子节点永远大于父节点。那么最小的数就是根节点了，干掉根节点，把最最下面子节点的数字放到这个根节点的位置，再对这个对进行对条件调整。干掉现在的根节点。重复上述步骤。</p>
</blockquote>
<pre><code>public class HeapSort {
private static int[] sort = new int[]{1,0,10,20,3,5,6,4,9,8,12,17,34,11};
public static void main(String[] args) {
    buildMaxHeapify(sort);
    heapSort(sort);
    print(sort);
}

private static void buildMaxHeapify(int[] data){
    //没有子节点的才需要创建最大堆，从最后一个的父节点开始
    int startIndex = getParentIndex(data.length - 1);
    //从尾端开始创建最大堆，每次都是正确的堆
    for (int i = startIndex; i &gt;= 0; i--) {
        maxHeapify(data, data.length, i);
    }
}

/**
 * 创建最大堆
 * @param data
 * @param heapSize需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了
 * @param index当前需要创建最大堆的位置
 */
private static void maxHeapify(int[] data, int heapSize, int index){
    // 当前点与左右子节点比较
    int left = getChildLeftIndex(index);
    int right = getChildRightIndex(index);

    int largest = index;
    if (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) {
        largest = left;
    }
    if (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) {
        largest = right;
    }
    //得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整
    if (largest != index) {
        int temp = data[index];
        data[index] = data[largest];
        data[largest] = temp;
        maxHeapify(data, heapSize, largest);
    }
}

/**
 * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的
 * @param data
 */
private static void heapSort(int[] data) {
    //末尾与头交换，交换后调整最大堆
    for (int i = data.length - 1; i &gt; 0; i--) {
        int temp = data[0];
        data[0] = data[i];
        data[i] = temp;
        maxHeapify(data, i, 0);
    }
}

/**
 * 父节点位置
 * @param current
 * @return
 */
private static int getParentIndex(int current){
    return (current - 1) &gt;&gt; 1;
}

/**
 * 左子节点position注意括号，加法优先级更高
 * @param current
 * @return
 */
private static int getChildLeftIndex(int current){
    return (current &lt;&lt; 1) + 1;
}

/**
 * 右子节点position
 * @param current
 * @return
 */
private static int getChildRightIndex(int current){
    return (current &lt;&lt; 1) + 2;
}

private static void print(int[] data){
    int pre = -2;
    for (int i = 0; i &lt; data.length; i++) {
        if (pre &lt; (int)getLog(i+1)) {
            pre = (int)getLog(i+1);
            System.out.println();
        } 
        System.out.print(data[i] + &quot; |&quot;);
    }
}

/**
 * 以2为底的对数
 * @param param
 * @return
 */
private static double getLog(double param){
    return Math.log(param)/Math.log(2);
}
}
</code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote>
<p>两个已经排好序的序列进行排序，各自第一个拿来比比，小的作为新的序列的第一个，这样比较到合二并一。也是典型的分而治之的思想。</p>
</blockquote>
<pre><code>static void merge_sort_recursive(int[] arr, int[] result, int start, int end) {
    if (start &gt;= end)
        return;
    int len = end - start, mid = (len &gt;&gt; 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    merge_sort_recursive(arr, result, start1, end1);
    merge_sort_recursive(arr, result, start2, end2);
    int k = start;
    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)
        result[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];
    while (start1 &lt;= end1)
        result[k++] = arr[start1++];
    while (start2 &lt;= end2)
        result[k++] = arr[start2++];
    for (k = start; k &lt;= end; k++)
        arr[k] = result[k];
}
public static void merge_sort(int[] arr) {
    int len = arr.length;
    int[] result = new int[len];
    merge_sort_recursive(arr, result, 0, len - 1);
}    
</code></pre><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><blockquote>
<pre><code>对整数进行排序。把所有数字搞成长度都一样，最高位开始比较，必到最后就是一个有序序列。
</code></pre></blockquote>
<pre><code>#!/usr/bin/env python
#encoding=utf-8
import math
def sort(a, radix=10):
    &quot;&quot;&quot;a为整数列表， radix为基数&quot;&quot;&quot;
    K = int(math.ceil(math.log(max(a), radix))) # 用K位数可表示任意整数
    bucket = [[] for i in range(radix)] # 不能用 [[]]*radix
    for i in range(1, K+1): # K次循环
        for val in a:
            bucket[val%(radix**i)/(radix**(i-1))].append(val) # 析取整数第K位数字 （从低到高）
        del a[:]
        for each in bucket:
            a.extend(each) # 桶合并
        bucket = [[] for i in range(radix)]
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[时间复杂度理解]]></title>
      <url>http://www.smallstrong.wang/2016/10/13/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><center>时间复杂度</center><br><a id="more"></a></p>
<blockquote>
<p>下载了编程之美之后里面看到了一个时间复杂度的概念，去了解了一下写下来，方便日后查看，我感觉这个复杂度其实就是程序需要执行的次数。而且一段程序中最后的算术表达式中会直接采用最高阶的复杂度来代替。</p>
</blockquote>
<ol>
<li>程序中一些正常的加减乘除以及输出等等一行代码的时间复杂度都是O(1)</li>
<li>程序中一个循环执行n次（内部不存在其他循环）的时间复杂度是O(n)</li>
<li>程序中双重循环如果一共执行n*n次那个的时间复杂度就是O(n^2)</li>
<li>如果程序是类似于下面这段代码，那么时间复杂度为O(log3n)</li>
</ol>
<pre><code>int i = 1;
while(i &lt; n){
    i = i * 3;
}
</code></pre><p><img src="/images/时间复杂度.png" alt="时间复杂度.png"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法之路-day01]]></title>
      <url>http://www.smallstrong.wang/2016/10/12/%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF-day01/</url>
      <content type="html"><![CDATA[<p><center>斐波那契数列</center><br><a id="more"></a></p>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre><code>public int getTheNum(int n){
    if(n &lt;= 0){
        return 0;
    }else if(n == 1){
        return 1;
    }else{
        return getTheNum(n -1) + getTheNum(n - 2);
    }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vim快捷键笔记]]></title>
      <url>http://www.smallstrong.wang/2016/10/12/vim%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><center>vim一些快捷键笔记</center><br><a id="more"></a></p>
<p>normal模式下<br>$  移至光标那行末尾</p>
<p>^  移至光标那行开头</p>
<p>gg 来到文档的第一行</p>
<p>dd 删除光标那行</p>
<p>yy 复制当前行</p>
<p>p  粘贴</p>
<p>u 撤销上一步操作</p>
<p>ctrl+r 回复上一步操作</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python-day04]]></title>
      <url>http://www.smallstrong.wang/2016/10/11/python-day04/</url>
      <content type="html"><![CDATA[<p><center>记录Python学习第四天</center><br><a id="more"></a></p>
<blockquote>
<p>python学习记录 day04</p>
</blockquote>
<h2 id="Django学习"><a href="#Django学习" class="headerlink" title="Django学习"></a>Django学习</h2><blockquote>
<p>安装Diango</p>
</blockquote>
<p>在pycharm中，第三方库的引入只要在project interpreter中搜索django,install一下就好了。</p>
<pre><code>import django
</code></pre><p>这行代码不报错就说明已经导入了！    </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[五分钟教你在VPS上搭建VPN]]></title>
      <url>http://www.smallstrong.wang/2016/10/11/%E4%BA%94%E5%88%86%E9%92%9F%E6%95%99%E4%BD%A0%E5%9C%A8VPS%E4%B8%8A%E6%90%AD%E5%BB%BAVPN/</url>
      <content type="html"><![CDATA[<p><center>老司机带你去墙外看看，来开车了坐稳！</center><br><a id="more"></a></p>
<blockquote>
<p>翻墙的正确姿势，你掌握了多少？</p>
</blockquote>
<h1 id="购买VPS主机（服务端）"><a href="#购买VPS主机（服务端）" class="headerlink" title="购买VPS主机（服务端）"></a>购买VPS主机（服务端）</h1><p>推荐性价比较高的VPS 搬瓦工<a href="https://bandwagonhost.com/" target="_blank" rel="external">https://bandwagonhost.com/</a></p>
<blockquote>
<p>上面的链接如果你打不开可以用下面这个</p>
</blockquote>
<p><a href="https://bwh1.net/index.php" target="_blank" rel="external">https://bwh1.net/index.php</a></p>
<h2 id="进入到主界面的时候，请你先注册账户密码"><a href="#进入到主界面的时候，请你先注册账户密码" class="headerlink" title="进入到主界面的时候，请你先注册账户密码"></a>进入到主界面的时候，请你先注册账户密码</h2><p>信息请认真填写哦~<br><img src="/images/register.png" alt="register.png"></p>
<h2 id="账户登录之后购买vps虚拟专用服务器啦"><a href="#账户登录之后购买vps虚拟专用服务器啦" class="headerlink" title="账户登录之后购买vps虚拟专用服务器啦"></a>账户登录之后购买vps虚拟专用服务器啦</h2><p>根据你的财力，在首页选择你的套餐，有月付季付半年付和年付四种方式。这个VPS支持支付宝支付。这个过程就跟你逛某宝买东西一样的流程，相信大家不会遇到问题。</p>
<h2 id="买好VPS之后，他会给你发一个邮件，里面有你的虚拟服务器IP地址以及端口号。自己注意保存啊，亲。"><a href="#买好VPS之后，他会给你发一个邮件，里面有你的虚拟服务器IP地址以及端口号。自己注意保存啊，亲。" class="headerlink" title="买好VPS之后，他会给你发一个邮件，里面有你的虚拟服务器IP地址以及端口号。自己注意保存啊，亲。"></a>买好VPS之后，他会给你发一个邮件，里面有你的虚拟服务器IP地址以及端口号。自己注意保存啊，亲。</h2><h2 id="管理你的VPS"><a href="#管理你的VPS" class="headerlink" title="管理你的VPS"></a>管理你的VPS</h2><p>首页点击VPS HOsting菜单，就会下方看到Services菜单，点击之后选择 My Services如下图<br><img src="/images/manage.png" alt="manage.png"><br>点击KiwiVM Control Panel<br>你会发现VPS预装了Centos 6 x86_64 </p>
<h2 id="安装Shadowsocks-Server"><a href="#安装Shadowsocks-Server" class="headerlink" title="安装Shadowsocks Server"></a>安装Shadowsocks Server</h2><p><img src="/images/ss.png" alt="ss.png"><br>直接安装就好了，搬瓦工现阶段支持Centos6。而上面预装的系统就是Centos 6 x86_64 。安装完毕之后看到Shadowsocks server controls窗口，从上到下一共三个参数：</p>
<ol>
<li>加密方式</li>
<li>ss端口号</li>
<li>连接ss的密码</li>
</ol>
<p>这些你都可以自由修改。但请你记住他们，我是把这些参数和购买vps之后的给我的IP地址和端口号都用记事本记录了，你也可以这么做，方便今后copy.</p>
<blockquote>
<p>好了到现在为止，服务端就已经OK啦，是不是肥肠简单啊。<br>偷偷告诉你，客户端配置更加简单，哈哈。</p>
</blockquote>
<h1 id="iOS-Android-Mac-Win-Linus安装ss客户端"><a href="#iOS-Android-Mac-Win-Linus安装ss客户端" class="headerlink" title="iOS,Android,Mac,Win,Linus安装ss客户端"></a>iOS,Android,Mac,Win,Linus安装ss客户端</h1><p><a href="https://shadowsocks.com/client.html" target="_blank" rel="external">https://shadowsocks.com/client.html</a><br>对应下载自己需要的客户端，然后对应在客户端中写入服务器设置。这边我简单介绍一下mac，以及iPhone上的ss客户端。</p>
<h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p>安装好小飞机之后，点开下拉菜单-&gt;服务器–&gt;服务器设置–&gt;添加<br>填写你IP地址，后面的端口号是你设置SS服务器的时候填的端口号一般默认443.对应选择好之前在ss服务器设置时候选择的加密方式，（别选错）。密码也是SS服务器设置时候提供的一串密码，然后选择你自己创建的这个服务区就OK了。</p>
<h2 id="iPhone"><a href="#iPhone" class="headerlink" title="iPhone"></a>iPhone</h2><p>先去APP Store下载SS客户端 Wingy （不收费），和上面Mac设置一样，对应填写IP 端口（默认443）密码 以及加密方式。保存搞定。</p>
<blockquote>
<p>科学上网，你值得拥有!</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python-day03]]></title>
      <url>http://www.smallstrong.wang/2016/10/10/python-day03/</url>
      <content type="html"><![CDATA[<p><center>记录Python学习第三天</center><br><a id="more"></a></p>
<blockquote>
<p>python学习记录 day03</p>
</blockquote>
<h1 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h1><blockquote>
<p>引入sys系统模块</p>
</blockquote>
<pre><code>import  sys
</code></pre><h2 id="添加第三方库（pycharm）"><a href="#添加第三方库（pycharm）" class="headerlink" title="添加第三方库（pycharm）"></a>添加第三方库（pycharm）</h2><p>打开setting里面找到 project：(你的工程名字)里面点绿色加号之后查询到自己想要添加的库就行了。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><blockquote>
<p>类似<strong>xxx</strong>这样的变量是特殊变量，可以被直接引用,一般文档注释用<br>类似_xxx和<strong>xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，</strong>abc等；</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[pyhton-day02]]></title>
      <url>http://www.smallstrong.wang/2016/10/09/pyhton-day02/</url>
      <content type="html"><![CDATA[<p><center>记录Python学习第二天</center><br><a id="more"></a></p>
<blockquote>
<p>python学习记录 day02</p>
</blockquote>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><blockquote>
<p>变量可以指向函数</p>
</blockquote>
<pre><code>f = abs
 f（-10）
 10
</code></pre><p>说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</p>
<blockquote>
<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
</blockquote>
<pre><code>def add(x, y, f):
    return f(x) + f(y)
add(-5, 6, abs)    
11
</code></pre><h1 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h1><blockquote>
<p>把这个list所有数字转为字符串：</p>
</blockquote>
<pre><code>list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]
</code></pre><p>#返回函数<br>    def lazy_sum(*args):<br>    def sum():<br>        ax = 0<br>        for n in args:<br>            ax = ax + n<br>        return ax<br>    return sum</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python day01]]></title>
      <url>http://www.smallstrong.wang/2016/10/08/python-day01/</url>
      <content type="html"><![CDATA[<p><center>记录Python学习第一天</center><br><a id="more"></a></p>
<blockquote>
<p>python学习记录 day01</p>
</blockquote>
<h2 id="安装开发环境（mac）"><a href="#安装开发环境（mac）" class="headerlink" title="安装开发环境（mac）"></a>安装开发环境（mac）</h2><h3 id="官网-www-python-org下载最新版本3-5-2，按照默认安装即可"><a href="#官网-www-python-org下载最新版本3-5-2，按照默认安装即可" class="headerlink" title="官网 www.python.org下载最新版本3.5.2，按照默认安装即可"></a>官网 <a href="www.python.org">www.python.org</a>下载最新版本3.5.2，按照默认安装即可</h3><h3 id="直接使用了集成开发环境pycharm-https-www-jetbrains-com-pycharm"><a href="#直接使用了集成开发环境pycharm-https-www-jetbrains-com-pycharm" class="headerlink" title="直接使用了集成开发环境pycharm https://www.jetbrains.com/pycharm/"></a>直接使用了集成开发环境pycharm <a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">https://www.jetbrains.com/pycharm/</a></h3><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>   tuple：元祖</p>
<pre><code>classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)  
</code></pre><p>   在java中没有元祖这个概念。可以理解成被final修饰的list集合。元祖被定义的时候就必须确定下来其元素。</p>
<p>   循环：for…in</p>
<pre><code>names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]
for name in names:
print(name)
</code></pre><p>  dict字典：java中的map集合</p>
<pre><code>d = {&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85}  
d[&apos;Michael&apos;]
95
</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:</p>
</blockquote>
<pre><code>def m(x):
       if x &gt;= 0:
           return 1
    else:
        return 2
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 屏幕适配不完全梳理]]></title>
      <url>http://www.smallstrong.wang/2016/09/25/Android-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%A2%B3%E7%90%86/</url>
      <content type="html"><![CDATA[<p><center>本文介绍Android屏幕适配的一些心得(坑)</center><br><a id="more"></a></p>
<blockquote>
<p>Android系统由于其开源性质，碎片化问题一直被人诟病。今天想梳理一下自己这些日子下来总结的屏幕适配的经验。恩，开始了。</p>
</blockquote>
<ul>
<li>屏幕尺寸，分辨率</li>
<li>基本概念（dp,dip,sp,px,dpi）</li>
<li>图片放入mdpi,hdpi,xhdpi,xxhdpi,xxxdpi文件夹的正确姿势</li>
<li>书写布局文件时候需要注意什么</li>
<li>开源的屏幕适配解决方案</li>
</ul>
<h2 id="屏幕尺寸，分辨率"><a href="#屏幕尺寸，分辨率" class="headerlink" title="屏幕尺寸，分辨率"></a>屏幕尺寸，分辨率</h2><p>我们先来看一张图（数据来自友盟2016年8月）</p>
<p><img src="/images/分辨率.png" alt="分辨率.png"></p>
<p>图中我们看到，排名前六的机型分辨率占到了九成以上的市场，因此适配他们基本就可以了。分别是：</p>
<ol>
<li>1280 x 720</li>
<li>1920 X 1080</li>
<li>854 x 480 </li>
<li>960 x 540</li>
<li>800 x 480</li>
<li>1184 x 720</li>
</ol>
<p>随着时间的推移，屏幕分辨率会越来越高，低分辨率屏手机市场份额会逐年递减。</p>
<p>屏幕尺寸：指屏幕对角线的长度。单位是英寸，1英寸=2.54厘米。平时我们说的几寸屏就是对角线的长度。</p>
<h2 id="基本概念（dp-dip-sp-px-dpi）"><a href="#基本概念（dp-dip-sp-px-dpi）" class="headerlink" title="基本概念（dp,dip,sp,px,dpi）"></a>基本概念（dp,dip,sp,px,dpi）</h2><p>这边我把他们分成三类</p>
<ol>
<li>px</li>
<li>dpi</li>
<li>dp,dip,sp</li>
</ol>
<p>px:1个像素点，我们平常说这个手机分辨率1280 x 720，就是屏幕上有1280 乘以 720个像素点。</p>
<p>dpi:屏幕像素密度的单位。上面说到一英尺是2.52cm对吧，dpi的概念就是一英尺就这个2.54cm里面包含多少个像素点。</p>
<p>dp == dip<br>dip全拼：Density Independent Pixels（密度无关像素）的缩写。</p>
<p>他们之间的关系可以用这个公式表示：px = dp * (dpi / 160)</p>
<p>sp:Google推荐些字体大小的时候用sp，概念和dp完全一样。（Android设置里面可以改字体大小，你用了sp就会有效果）</p>
<h2 id="图片放入mdpi-hdpi-xhdpi-xxhdpi-xxxdpi文件夹的正确姿势"><a href="#图片放入mdpi-hdpi-xhdpi-xxhdpi-xxxdpi文件夹的正确姿势" class="headerlink" title="图片放入mdpi,hdpi,xhdpi,xxhdpi,xxxdpi文件夹的正确姿势"></a>图片放入mdpi,hdpi,xhdpi,xxhdpi,xxxdpi文件夹的正确姿势</h2><p>一般公司都会给两套图来做图片适配。然后我们公司UI妹子给的两套图就是适配ios那边的两套图。原型图是iPhone5的1136x640分辨率的。之后生成的一倍图与两倍图，然后丢了过来。然后我就斯巴达了，因为图片如果用wrap_content的话，要么太大要么太小，然后我每次就估摸着自己摸索是多少dp,也还算能凑合过去。一次写底部导航栏的时候，radiobutton在xml里面是不能设置图片大小的只能在代码中改。我其实当时内心是哟欧草泥马奔腾的。为了让这些个草泥马不奔腾，我觉得去找UI妹子要图。</p>
<p>先看张图</p>
<p><img src="/images/dpi.png" alt="dpi.png"></p>
<p>手机的像素密度不同就会去加载对应文件夹下面的图片。那要是没有怎么办，放心他会自动去找最相近文件夹下面的同名图片，不过会有那么一点变化，不是加载其图片真实大小，而是经过一定比例的缩放，我们来看一下这个比例是多少：</p>
<p>mdpi：hdpi：xhdpi：xxhdpi：xxxhdpi=2：3：4：6：8 的尺寸比例进行缩放。</p>
<p>假设我的手机是1280 x 720分辨率,经过计算我应该去xhdpi文件夹下面找图片资源，丫的没有，去xxhdpi里面一找，发现有了。是一张120px x 120px的图片，那么好我们换算一下 120 x（2/3）= 80 px，也就是我其实加载到内存里面是进行2/3倍的缩放的，同理放大也是一样的。不过这边提到一点，低分辨率图片放大会失真，建议放正确分辨率的图片到高分辨图片文件夹中，这样会避免失真的烦恼。</p>
<p>总结（根据主流分辨率）：</p>
<p>hdpi   对应 854 x 480  960 x 540 800 x 480<br>xhdpi  对应 1280 x 720 1184 x 720<br>xxhdpi 对应 1920 X 1080</p>
<p>基本上我要的两套图我就丢 xhdoi xxhdpi里面。</p>
<p>接着上面那个梗，最后和ui妹子给出了个方案原型图是750*1334，输出两套图，两倍于三倍图。虽然不是最理想的（最理想就是720 x 1280就给我这个机型切出来的大小，但是一个公司就一个UI妹子，所以折中了一下），不过相差不是很大了，能接受了。这边提供一个链接，说的挺不错。</p>
<p><a href="http://www.sketchs.cn/tutorials/detail/257.html" target="_blank" rel="external">点我，切图就要这么切</a></p>
<h2 id="书写布局文件时候需要注意什么"><a href="#书写布局文件时候需要注意什么" class="headerlink" title="书写布局文件时候需要注意什么"></a>书写布局文件时候需要注意什么</h2><p>使用wrap_content、match_parent、weight，dp，sp这是官方给出的方案，的确有道理。我写布局就是尽量用权重，其实原来就是百分比布局。</p>
<p>不过还是有一些坑的，例如：</p>
<ol>
<li>dp写布局要小心一点，因为在同分辨率不同尺寸下的手机里面出来效果是不一样的，Android机子还真有这种情况。</li>
<li>关于sp，说实话从内心来讲我是拒绝的，因为啊，在设置中改变字体大小，调最大，我了个去，你会发现自己写的好好的布局显现出来超级难看，不忍直视。虽然官方是推荐sp，但是我内心还是向往dp的（项目中还是sp,习惯了，毕竟少有闲人去调整字体大小，真改了，我呵呵）</li>
<li>在你的UI给你一些不那么正常图的时候（分辨率乱来），wrap_content写imageview控件就有那么点风险了。</li>
</ol>
<h2 id="开源的屏幕适配解决方案"><a href="#开源的屏幕适配解决方案" class="headerlink" title="开源的屏幕适配解决方案"></a>开源的屏幕适配解决方案</h2><p>屏幕适配终结者，百分比适配。</p>
<p><a href="https://github.com/hongyangAndroid/AndroidAutoLayout" target="_blank" rel="external">鸿洋的解决方案，直接接入</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023#使用非密度制约像素" target="_blank" rel="external">凯子哥</a></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/46695347" target="_blank" rel="external">鸿洋</a></p>
<p><a href="http://stormzhang.com/android/2014/05/16/android-screen-adaptation/" target="_blank" rel="external">stormzhang</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 64K]]></title>
      <url>http://www.smallstrong.wang/2016/09/06/Android-64K/</url>
      <content type="html"><![CDATA[<p><center>64K限制引发的血案</center><br><a id="more"></a></p>
<h1 id="Android-64K限制"><a href="#Android-64K限制" class="headerlink" title="Android 64K限制"></a>Android 64K限制</h1><p>有一天被这么一个懵逼的错误搞了个半死，在4.4一下版本的时候都不能正常运行，原因是他</p>
<pre><code>java.lang.NoClassDefFoundError
</code></pre><p>一开始我一直纠结是gradle是 buildToolsVersion 的问题，于是我尝试修改版本号，无济于事。我Google了很久终于在stackoverflow上找到了答案。</p>
<p>打包自己的工程项目，改后缀.zip，解压之后你会发现classes.dex和classes2.dex，两家伙！！！</p>
<blockquote>
<p>Android平台的Java虚拟机Dalvik执行Dex程序时，使用的是short类型来索引DEX文件中的方法。这就意味着单个Dex文件可被引用的方法总数被限制为64x1024, 即65536。简单的说就是Dalvik虚拟机只能加载一个字节码classed.dex，而    ART虚拟机支持从apk中加载多个dex文件，这就是为什么我在5.1系统的三星手机上运行ok，而在4.4.2的oppo手机上程序闪奔的原因！</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>接下去去几步骤一步都别少：</p>
<h3 id="1-在build-gradle中配置了multiDexEnabled-true"><a href="#1-在build-gradle中配置了multiDexEnabled-true" class="headerlink" title="1.在build.gradle中配置了multiDexEnabled true"></a>1.在build.gradle中配置了multiDexEnabled true</h3><p><img src="/images/适配01.png" alt="适配01"></p>
<h3 id="2-android-support-multidex"><a href="#2-android-support-multidex" class="headerlink" title="2.android.support.multidex"></a>2.android.support.multidex</h3><p><img src="/images/适配02.png" alt="适配02"></p>
<h3 id="3-继承MultiDexApplication"><a href="#3-继承MultiDexApplication" class="headerlink" title="3.继承MultiDexApplication"></a>3.继承MultiDexApplication</h3><blockquote>
<p>(如果你的应用入口直接就是Application,那你直接在Manifest里面直接改成MultiDexApplication作为程序入口就over了)</p>
</blockquote>
<p><img src="/images/适配03.png" alt="适配03"></p>
<h3 id="4-重写attachBaseContext方法"><a href="#4-重写attachBaseContext方法" class="headerlink" title="4.重写attachBaseContext方法"></a>4.重写attachBaseContext方法</h3><p><img src="/images/适配04.png" alt="适配04"></p>
<p>在下就是死在第三部么有加，简直欲仙欲死。由此我抽空去了解了一下Android的类加载机制，然后又顺势了解了热部署。还算是赚到了不少哈哈！这波不亏~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android优雅实现渐变色的进度条]]></title>
      <url>http://www.smallstrong.wang/2016/09/06/ProgressBar/</url>
      <content type="html"><![CDATA[<p><center>本文介绍在使用progress如何实现渐变色的进度条</center><br><a id="more"></a></p>
<h1 id="Android优雅实现渐变色的进度条"><a href="#Android优雅实现渐变色的进度条" class="headerlink" title="Android优雅实现渐变色的进度条"></a>Android优雅实现渐变色的进度条</h1><p><img src="/images/progress.png" alt="progress.png"></p>
<h2 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h2><pre><code>&lt;android.support.v4.widget.ContentLoadingProgressBar
            android:id=&quot;@+id/pb&quot;
            style=&quot;?android:attr/progressBarStyleHorizontal&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;6dp&quot;
            android:layout_marginBottom=&quot;5dp&quot;
            android:layout_marginLeft=&quot;16dp&quot;
            android:layout_marginRight=&quot;16dp&quot;
            android:max=&quot;10000&quot;
            android:progressDrawable=&quot;@drawable/progress_red&quot;/&gt;
</code></pre><h2 id="progress-red-xml"><a href="#progress-red-xml" class="headerlink" title="progress_red.xml"></a>progress_red.xml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;item android:id=&quot;@android:id/background&quot;&gt;
    &lt;shape&gt;
        &lt;corners android:radius=&quot;5dip&quot; /&gt;
        &lt;gradient
            android:angle=&quot;270&quot;
            android:centerColor=&quot;@color/gray_bit&quot;
            android:centerY=&quot;0.75&quot;
            android:endColor=&quot;@color/gray_bit&quot;
            android:startColor=&quot;@color/gray_bit&quot; /&gt;
    &lt;/shape&gt;
&lt;/item&gt;

&lt;item android:id=&quot;@android:id/progress&quot;&gt;
    &lt;clip&gt;
        &lt;shape&gt;
            &lt;corners android:radius=&quot;5dip&quot; /&gt;
            &lt;gradient
                android:endColor=&quot;@color/yellow_deep&quot;
                android:centerColor=&quot;@color/yellow_middle&quot;
                android:startColor=&quot;@color/yellow_little&quot; /&gt;
        &lt;/shape&gt;
    &lt;/clip&gt;
&lt;/item&gt;
&lt;/layer-list&gt;            
</code></pre>]]></content>
    </entry>
    
  
  
</search>
